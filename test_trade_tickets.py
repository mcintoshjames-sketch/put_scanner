"""
Test Trade Order Tickets Generated by Trade Execution Section

Validates that order tickets for all 4 strategies (CSP, CC, Collar, Iron Condor)
have correct structure, required fields, and valid Schwab API format.
"""

import json
from datetime import datetime
from providers.schwab_trading import SchwabTrader


def validate_option_symbol(symbol: str, expected_type: str = None) -> dict:
    """
    Validate Schwab option symbol format.
    Expected format: "SYMBOL  YYMMDDC/PSTRIKE"
    Example: "AAPL  251219C00150000" (6-char padded symbol + date + type + 8-digit strike)
    
    Returns dict with validation results and parsed components.
    """
    if not symbol or not isinstance(symbol, str):
        return {"valid": False, "error": "Symbol is missing or not a string"}
    
    if len(symbol) != 21:
        return {"valid": False, "error": f"Symbol length is {len(symbol)}, expected 21"}
    
    ticker = symbol[:6].strip()
    date_str = symbol[6:12]
    opt_type = symbol[12]
    strike_str = symbol[13:21]
    
    # Validate date format (YYMMDD)
    try:
        exp_date = datetime.strptime(date_str, "%y%m%d")
    except ValueError:
        return {"valid": False, "error": f"Invalid date format: {date_str}"}
    
    # Validate option type
    if opt_type not in ['C', 'P']:
        return {"valid": False, "error": f"Invalid option type: {opt_type} (expected C or P)"}
    
    # Validate expected type if provided
    if expected_type and opt_type != expected_type:
        return {"valid": False, "error": f"Expected {expected_type} but got {opt_type}"}
    
    # Validate strike format (8 digits)
    if not strike_str.isdigit() or len(strike_str) != 8:
        return {"valid": False, "error": f"Invalid strike format: {strike_str}"}
    
    strike_price = int(strike_str) / 1000.0
    
    return {
        "valid": True,
        "ticker": ticker,
        "expiration": exp_date.strftime("%Y-%m-%d"),
        "type": "CALL" if opt_type == "C" else "PUT",
        "strike": strike_price
    }


def validate_order_structure(order: dict) -> dict:
    """Validate basic order structure required by Schwab API."""
    errors = []
    warnings = []
    
    # Required fields
    required_fields = ["orderType", "session", "duration", "orderStrategyType", "orderLegCollection"]
    for field in required_fields:
        if field not in order:
            errors.append(f"Missing required field: {field}")
    
    # Validate orderType
    valid_order_types = ["MARKET", "LIMIT", "STOP", "STOP_LIMIT", "NET_CREDIT", "NET_DEBIT"]
    if "orderType" in order and order["orderType"] not in valid_order_types:
        errors.append(f"Invalid orderType: {order['orderType']}")
    
    # Validate session
    valid_sessions = ["NORMAL", "AM", "PM", "SEAMLESS"]
    if "session" in order and order["session"] not in valid_sessions:
        errors.append(f"Invalid session: {order['session']}")
    
    # Validate duration
    valid_durations = ["DAY", "GTC", "FILL_OR_KILL"]
    if "duration" in order and order["duration"] not in valid_durations:
        errors.append(f"Invalid duration: {order['duration']}")
    
    # Check for price field on LIMIT/NET_CREDIT/NET_DEBIT orders
    if "orderType" in order and order["orderType"] in ["LIMIT", "NET_CREDIT", "NET_DEBIT"]:
        if "price" not in order:
            errors.append(f"Missing price field for {order['orderType']} order")
        elif not isinstance(order["price"], (int, float)) or order["price"] <= 0:
            errors.append(f"Invalid price: {order.get('price')}")
    
    # Validate legs
    if "orderLegCollection" in order:
        legs = order["orderLegCollection"]
        if not isinstance(legs, list) or len(legs) == 0:
            errors.append("orderLegCollection must be a non-empty list")
        else:
            for i, leg in enumerate(legs):
                leg_errors = validate_order_leg(leg, i)
                errors.extend(leg_errors)
    
    # GTC warning
    if "duration" in order and order["duration"] == "GTC":
        warnings.append("GTC orders remain active until filled or cancelled")
    
    return {
        "valid": len(errors) == 0,
        "errors": errors,
        "warnings": warnings
    }


def validate_order_leg(leg: dict, leg_index: int) -> list:
    """Validate individual order leg."""
    errors = []
    
    # Required fields
    if "instruction" not in leg:
        errors.append(f"Leg {leg_index}: Missing instruction")
    else:
        valid_instructions = ["BUY_TO_OPEN", "SELL_TO_OPEN", "BUY_TO_CLOSE", "SELL_TO_CLOSE"]
        if leg["instruction"] not in valid_instructions:
            errors.append(f"Leg {leg_index}: Invalid instruction: {leg['instruction']}")
    
    if "quantity" not in leg:
        errors.append(f"Leg {leg_index}: Missing quantity")
    elif not isinstance(leg["quantity"], int) or leg["quantity"] <= 0:
        errors.append(f"Leg {leg_index}: Invalid quantity: {leg['quantity']}")
    
    if "instrument" not in leg:
        errors.append(f"Leg {leg_index}: Missing instrument")
    else:
        instrument = leg["instrument"]
        if "symbol" not in instrument:
            errors.append(f"Leg {leg_index}: Missing symbol")
        if "assetType" not in instrument:
            errors.append(f"Leg {leg_index}: Missing assetType")
        elif instrument["assetType"] != "OPTION":
            errors.append(f"Leg {leg_index}: Expected assetType=OPTION, got {instrument['assetType']}")
    
    return errors


def test_csp_order():
    """Test Cash-Secured Put order ticket."""
    print("\n" + "="*60)
    print("TEST 1: Cash-Secured Put (CSP) Order")
    print("="*60)
    
    trader = SchwabTrader(dry_run=True)
    
    # Create CSP order
    order = trader.create_cash_secured_put_order(
        symbol="AAPL",
        expiration="2025-12-19",
        strike=180.0,
        quantity=2,
        limit_price=3.50,
        duration="GTC"
    )
    
    print("\nðŸ“‹ Order Ticket:")
    print(json.dumps(order, indent=2))
    
    # Validate structure
    validation = validate_order_structure(order)
    
    print("\nâœ… Validation Results:")
    print(f"Valid: {validation['valid']}")
    if validation['errors']:
        print("âŒ Errors:")
        for error in validation['errors']:
            print(f"  - {error}")
    if validation['warnings']:
        print("âš ï¸  Warnings:")
        for warning in validation['warnings']:
            print(f"  - {warning}")
    
    # Validate option symbol
    if order.get("orderLegCollection"):
        leg = order["orderLegCollection"][0]
        symbol = leg["instrument"]["symbol"]
        symbol_validation = validate_option_symbol(symbol, expected_type="P")
        
        print(f"\nðŸ” Option Symbol Validation:")
        print(f"Symbol: {symbol}")
        if symbol_validation["valid"]:
            print(f"âœ… Valid PUT option")
            print(f"  Ticker: {symbol_validation['ticker']}")
            print(f"  Expiration: {symbol_validation['expiration']}")
            print(f"  Strike: ${symbol_validation['strike']:.2f}")
        else:
            print(f"âŒ Invalid: {symbol_validation['error']}")
    
    # Check specific fields
    print(f"\nðŸ“Š Order Details:")
    print(f"  Type: {order.get('orderType')} (expected: LIMIT)")
    print(f"  Duration: {order.get('duration')} (expected: GTC)")
    print(f"  Price: ${order.get('price'):.2f} (expected: $3.50)")
    print(f"  Legs: {len(order.get('orderLegCollection', []))} (expected: 1)")
    print(f"  Instruction: {order['orderLegCollection'][0]['instruction']} (expected: SELL_TO_OPEN)")
    print(f"  Quantity: {order['orderLegCollection'][0]['quantity']} (expected: 2)")
    
    assert validation['valid'], "CSP order validation failed"
    assert order['orderType'] == 'LIMIT', "Wrong order type"
    assert order['price'] == 3.50, "Wrong price"
    assert len(order['orderLegCollection']) == 1, "Wrong number of legs"
    assert order['orderLegCollection'][0]['instruction'] == 'SELL_TO_OPEN', "Wrong instruction"
    
    print("\nâœ… CSP test passed!")
    return True


def test_covered_call_order():
    """Test Covered Call order ticket."""
    print("\n" + "="*60)
    print("TEST 2: Covered Call (CC) Order")
    print("="*60)
    
    trader = SchwabTrader(dry_run=True)
    
    # Create CC order
    order = trader.create_covered_call_order(
        symbol="TSLA",
        expiration="2025-11-15",
        strike=320.0,
        quantity=3,
        limit_price=5.50,
        duration="DAY"
    )
    
    print("\nðŸ“‹ Order Ticket:")
    print(json.dumps(order, indent=2))
    
    # Validate structure
    validation = validate_order_structure(order)
    
    print("\nâœ… Validation Results:")
    print(f"Valid: {validation['valid']}")
    if validation['errors']:
        print("âŒ Errors:")
        for error in validation['errors']:
            print(f"  - {error}")
    if validation['warnings']:
        print("âš ï¸  Warnings:")
        for warning in validation['warnings']:
            print(f"  - {warning}")
    
    # Validate option symbol
    if order.get("orderLegCollection"):
        leg = order["orderLegCollection"][0]
        symbol = leg["instrument"]["symbol"]
        symbol_validation = validate_option_symbol(symbol, expected_type="C")
        
        print(f"\nðŸ” Option Symbol Validation:")
        print(f"Symbol: {symbol}")
        if symbol_validation["valid"]:
            print(f"âœ… Valid CALL option")
            print(f"  Ticker: {symbol_validation['ticker']}")
            print(f"  Expiration: {symbol_validation['expiration']}")
            print(f"  Strike: ${symbol_validation['strike']:.2f}")
        else:
            print(f"âŒ Invalid: {symbol_validation['error']}")
    
    print(f"\nðŸ“Š Order Details:")
    print(f"  Type: {order.get('orderType')} (expected: LIMIT)")
    print(f"  Duration: {order.get('duration')} (expected: DAY)")
    print(f"  Price: ${order.get('price'):.2f} (expected: $5.50)")
    print(f"  Legs: {len(order.get('orderLegCollection', []))} (expected: 1)")
    print(f"  Instruction: {order['orderLegCollection'][0]['instruction']} (expected: SELL_TO_OPEN)")
    
    assert validation['valid'], "CC order validation failed"
    assert order['orderType'] == 'LIMIT', "Wrong order type"
    assert len(order['orderLegCollection']) == 1, "Wrong number of legs"
    
    print("\nâœ… Covered Call test passed!")
    return True


def test_collar_order():
    """Test Collar order ticket."""
    print("\n" + "="*60)
    print("TEST 3: Collar Order")
    print("="*60)
    
    trader = SchwabTrader(dry_run=True)
    
    # Create Collar order
    order = trader.create_collar_order(
        symbol="NVDA",
        expiration="2025-12-19",
        call_strike=200.0,
        put_strike=160.0,
        quantity=1,
        limit_price=1.50,
        duration="GTC"
    )
    
    print("\nðŸ“‹ Order Ticket:")
    print(json.dumps(order, indent=2))
    
    # Validate structure
    validation = validate_order_structure(order)
    
    print("\nâœ… Validation Results:")
    print(f"Valid: {validation['valid']}")
    if validation['errors']:
        print("âŒ Errors:")
        for error in validation['errors']:
            print(f"  - {error}")
    if validation['warnings']:
        print("âš ï¸  Warnings:")
        for warning in validation['warnings']:
            print(f"  - {warning}")
    
    # Validate option symbols for both legs
    if order.get("orderLegCollection") and len(order["orderLegCollection"]) == 2:
        print(f"\nðŸ” Option Symbol Validation:")
        
        # Leg 1: Short Call
        call_leg = order["orderLegCollection"][0]
        call_symbol = call_leg["instrument"]["symbol"]
        call_validation = validate_option_symbol(call_symbol, expected_type="C")
        
        print(f"\nLeg 1 - Short Call:")
        print(f"  Symbol: {call_symbol}")
        print(f"  Instruction: {call_leg['instruction']} (expected: SELL_TO_OPEN)")
        if call_validation["valid"]:
            print(f"  âœ… Valid CALL - Strike: ${call_validation['strike']:.2f}")
        else:
            print(f"  âŒ Invalid: {call_validation['error']}")
        
        # Leg 2: Long Put
        put_leg = order["orderLegCollection"][1]
        put_symbol = put_leg["instrument"]["symbol"]
        put_validation = validate_option_symbol(put_symbol, expected_type="P")
        
        print(f"\nLeg 2 - Long Put:")
        print(f"  Symbol: {put_symbol}")
        print(f"  Instruction: {put_leg['instruction']} (expected: BUY_TO_OPEN)")
        if put_validation["valid"]:
            print(f"  âœ… Valid PUT - Strike: ${put_validation['strike']:.2f}")
        else:
            print(f"  âŒ Invalid: {put_validation['error']}")
        
        # Verify strike relationship (put < call)
        if call_validation["valid"] and put_validation["valid"]:
            if put_validation["strike"] < call_validation["strike"]:
                print(f"\nâœ… Strike relationship correct: PUT ${put_validation['strike']:.2f} < CALL ${call_validation['strike']:.2f}")
            else:
                print(f"\nâŒ Strike relationship wrong: PUT should be < CALL")
    
    print(f"\nðŸ“Š Order Details:")
    print(f"  Type: {order.get('orderType')} (expected: NET_CREDIT)")
    print(f"  Duration: {order.get('duration')} (expected: GTC)")
    print(f"  Price: ${order.get('price'):.2f} (expected: $1.50)")
    print(f"  Legs: {len(order.get('orderLegCollection', []))} (expected: 2)")
    
    assert validation['valid'], "Collar order validation failed"
    assert order['orderType'] == 'NET_CREDIT', "Wrong order type"
    assert len(order['orderLegCollection']) == 2, "Wrong number of legs"
    assert order['orderLegCollection'][0]['instruction'] == 'SELL_TO_OPEN', "Leg 1 should be SELL"
    assert order['orderLegCollection'][1]['instruction'] == 'BUY_TO_OPEN', "Leg 2 should be BUY"
    
    print("\nâœ… Collar test passed!")
    return True


def test_iron_condor_order():
    """Test Iron Condor order ticket."""
    print("\n" + "="*60)
    print("TEST 4: Iron Condor Order")
    print("="*60)
    
    trader = SchwabTrader(dry_run=True)
    
    # Create Iron Condor order
    order = trader.create_iron_condor_order(
        symbol="SPY",
        expiration="2025-12-19",
        long_put_strike=540.0,
        short_put_strike=550.0,
        short_call_strike=590.0,
        long_call_strike=600.0,
        quantity=2,
        limit_price=2.50,
        duration="DAY"
    )
    
    print("\nðŸ“‹ Order Ticket:")
    print(json.dumps(order, indent=2))
    
    # Validate structure
    validation = validate_order_structure(order)
    
    print("\nâœ… Validation Results:")
    print(f"Valid: {validation['valid']}")
    if validation['errors']:
        print("âŒ Errors:")
        for error in validation['errors']:
            print(f"  - {error}")
    if validation['warnings']:
        print("âš ï¸  Warnings:")
        for warning in validation['warnings']:
            print(f"  - {warning}")
    
    # Validate all 4 legs
    if order.get("orderLegCollection") and len(order["orderLegCollection"]) == 4:
        print(f"\nðŸ” Option Symbol Validation:")
        
        leg_info = []
        expected_instructions = ["BUY_TO_OPEN", "SELL_TO_OPEN", "SELL_TO_OPEN", "BUY_TO_OPEN"]
        expected_types = ["P", "P", "C", "C"]
        leg_names = ["Long Put", "Short Put", "Short Call", "Long Call"]
        
        for i, (leg, expected_inst, expected_type, name) in enumerate(zip(
            order["orderLegCollection"], expected_instructions, expected_types, leg_names
        )):
            symbol = leg["instrument"]["symbol"]
            instruction = leg["instruction"]
            symbol_validation = validate_option_symbol(symbol, expected_type=expected_type)
            
            print(f"\nLeg {i+1} - {name}:")
            print(f"  Symbol: {symbol}")
            print(f"  Instruction: {instruction} (expected: {expected_inst})")
            
            if symbol_validation["valid"]:
                print(f"  âœ… Valid {symbol_validation['type']} - Strike: ${symbol_validation['strike']:.2f}")
                leg_info.append({
                    "name": name,
                    "type": symbol_validation["type"],
                    "strike": symbol_validation["strike"],
                    "instruction": instruction
                })
            else:
                print(f"  âŒ Invalid: {symbol_validation['error']}")
            
            if instruction != expected_inst:
                print(f"  âŒ Wrong instruction!")
        
        # Verify strike relationships
        if len(leg_info) == 4:
            print(f"\nðŸ” Strike Relationship Validation:")
            lp_strike = leg_info[0]["strike"]
            sp_strike = leg_info[1]["strike"]
            sc_strike = leg_info[2]["strike"]
            lc_strike = leg_info[3]["strike"]
            
            print(f"  Long Put:   ${lp_strike:.2f}")
            print(f"  Short Put:  ${sp_strike:.2f}")
            print(f"  Short Call: ${sc_strike:.2f}")
            print(f"  Long Call:  ${lc_strike:.2f}")
            
            all_correct = True
            if lp_strike < sp_strike:
                print(f"  âœ… Put spread correct: Long Put < Short Put")
            else:
                print(f"  âŒ Put spread wrong: Long Put should be < Short Put")
                all_correct = False
            
            if sp_strike < sc_strike:
                print(f"  âœ… Range correct: Short Put < Short Call")
            else:
                print(f"  âŒ Range wrong: Short Put should be < Short Call")
                all_correct = False
            
            if sc_strike < lc_strike:
                print(f"  âœ… Call spread correct: Short Call < Long Call")
            else:
                print(f"  âŒ Call spread wrong: Short Call should be < Long Call")
                all_correct = False
            
            # Calculate metrics
            put_spread_width = sp_strike - lp_strike
            call_spread_width = lc_strike - sc_strike
            range_width = sc_strike - sp_strike
            
            print(f"\nðŸ“Š Spread Metrics:")
            print(f"  Put Spread Width:  ${put_spread_width:.2f}")
            print(f"  Call Spread Width: ${call_spread_width:.2f}")
            print(f"  Profit Range:      ${range_width:.2f}")
            print(f"  Net Credit:        ${order.get('price', 0):.2f}")
            print(f"  Max Risk:          ${max(put_spread_width, call_spread_width) - order.get('price', 0):.2f}")
            
            assert all_correct, "Strike relationships incorrect"
    
    print(f"\nðŸ“Š Order Details:")
    print(f"  Type: {order.get('orderType')} (expected: NET_CREDIT)")
    print(f"  Duration: {order.get('duration')} (expected: DAY)")
    print(f"  Price: ${order.get('price'):.2f} (expected: $2.50)")
    print(f"  Legs: {len(order.get('orderLegCollection', []))} (expected: 4)")
    
    assert validation['valid'], "Iron Condor order validation failed"
    assert order['orderType'] == 'NET_CREDIT', "Wrong order type"
    assert len(order['orderLegCollection']) == 4, "Wrong number of legs"
    
    print("\nâœ… Iron Condor test passed!")
    return True


def test_order_validation_catches_errors():
    """Test that validation catches common errors."""
    print("\n" + "="*60)
    print("TEST 5: Validation Error Detection")
    print("="*60)
    
    # Test 1: Missing required fields
    print("\nðŸ§ª Test 5.1: Missing required fields")
    bad_order = {
        "orderType": "LIMIT",
        # Missing: session, duration, orderStrategyType, orderLegCollection
    }
    validation = validate_order_structure(bad_order)
    print(f"  Expected to fail: {not validation['valid']} âœ…")
    print(f"  Errors found: {len(validation['errors'])}")
    assert not validation['valid'], "Should have failed validation"
    
    # Test 2: Invalid order type
    print("\nðŸ§ª Test 5.2: Invalid order type")
    bad_order = {
        "orderType": "INVALID_TYPE",
        "session": "NORMAL",
        "duration": "DAY",
        "orderStrategyType": "SINGLE",
        "orderLegCollection": []
    }
    validation = validate_order_structure(bad_order)
    print(f"  Expected to fail: {not validation['valid']} âœ…")
    assert not validation['valid'], "Should have caught invalid order type"
    
    # Test 3: Missing price on LIMIT order
    print("\nðŸ§ª Test 5.3: Missing price on LIMIT order")
    bad_order = {
        "orderType": "LIMIT",
        "session": "NORMAL",
        "duration": "DAY",
        "orderStrategyType": "SINGLE",
        "orderLegCollection": [
            {
                "instruction": "SELL_TO_OPEN",
                "quantity": 1,
                "instrument": {"symbol": "TEST", "assetType": "OPTION"}
            }
        ]
        # Missing: price field
    }
    validation = validate_order_structure(bad_order)
    print(f"  Expected to fail: {not validation['valid']} âœ…")
    assert not validation['valid'], "Should have caught missing price"
    
    # Test 4: Invalid option symbol
    print("\nðŸ§ª Test 5.4: Invalid option symbol format")
    invalid_symbols = [
        "AAPL251219C150",  # Too short
        "AAPL  25121XC00150000",  # Invalid date
        "AAPL  251219X00150000",  # Invalid type (X)
        "AAPL  251219C0015000",  # Strike wrong length
    ]
    for symbol in invalid_symbols:
        validation = validate_option_symbol(symbol)
        print(f"  '{symbol}': {not validation['valid']} âœ…")
        assert not validation['valid'], f"Should have caught invalid symbol: {symbol}"
    
    print("\nâœ… Validation error detection test passed!")
    return True


def run_all_tests():
    """Run all trade ticket validation tests."""
    print("\n" + "="*60)
    print("TRADE EXECUTION ORDER TICKET VALIDATION SUITE")
    print("="*60)
    print("\nValidating order tickets for all 4 strategies:")
    print("  1. Cash-Secured Put (CSP)")
    print("  2. Covered Call (CC)")
    print("  3. Collar")
    print("  4. Iron Condor")
    print("  5. Error Detection")
    
    tests = [
        test_csp_order,
        test_covered_call_order,
        test_collar_order,
        test_iron_condor_order,
        test_order_validation_catches_errors
    ]
    
    passed = 0
    failed = 0
    
    for test in tests:
        try:
            if test():
                passed += 1
        except AssertionError as e:
            failed += 1
            print(f"\nâŒ TEST FAILED: {e}")
        except Exception as e:
            failed += 1
            print(f"\nâŒ TEST ERROR: {e}")
            import traceback
            traceback.print_exc()
    
    # Summary
    print("\n" + "="*60)
    print("TEST SUMMARY")
    print("="*60)
    print(f"Total Tests: {len(tests)}")
    print(f"âœ… Passed: {passed}")
    print(f"âŒ Failed: {failed}")
    
    if failed == 0:
        print("\nðŸŽ‰ ALL TESTS PASSED! Trade tickets are valid.")
        print("\nâœ… All order tickets conform to Schwab API format")
        print("âœ… Option symbols are correctly formatted")
        print("âœ… Strike relationships are logical")
        print("âœ… Multi-leg orders have correct leg ordering")
        print("âœ… Validation catches common errors")
    else:
        print("\nâš ï¸  SOME TESTS FAILED - Please review errors above")
        return False
    
    return True


if __name__ == "__main__":
    success = run_all_tests()
    exit(0 if success else 1)
